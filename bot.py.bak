#bot.py

from twitchio.ext import commands
from twitchio import channel, chatter, FollowEvent, ChannelInfo, Clip, User
import random
import re
import os
# from os import environ
from dotenv import load_dotenv
from my_commands import string_commands
# from my_commands.string_commands import derp, uwu, uhm
#from alpha.eng_funcs import EngFuncs as eng
#eng = EngFuncs()

# Load and assign environment variables
env_file = ".bot.env"
load_dotenv(env_file)
env_keys = ('ACCESS_TOKEN', 'CLIENT_ID', 'BOT_NICK', 'BOT_PREFIX', 'INITIAL_CHANNELS')
ENV = {k: v for k, v in os.environ.items() if k in env_keys}
ENV['BOT_PREFIX'] = ENV['BOT_PREFIX'].split(',')
ENV['INITIAL_CHANNELS'] = ENV['INITIAL_CHANNELS'].split(',')

class BaseBot(commands.Bot):
    '''Base class for bot configs containing default commands and variables.'''
    def __init__(self):
        self.display_name = ENV['BOT_NICK']
        self.channels = ENV['INITIAL_CHANNELS']

        super().__init__(
            # token=os.environ.get('ACCESS_TOKEN'),
            # client_secret=os.environ.get('CLIENT_ID'),
            # nick=os.environ.get('BOT_NICK'),
            # prefix=os.environ.get('BOT_PREFIX').split(','),
            # initial_channels=os.environ.get('INITIAL_CHANNELS').split(',')
            token=ENV['ACCESS_TOKEN'],
            client_secret=ENV['CLIENT_ID'],
            nick=ENV['BOT_NICK'],
            prefix=ENV['BOT_PREFIX'],
            initial_channels=ENV['INITIAL_CHANNELS']
            )

    async def event_ready(self):
        # Post a message in the console upon connection
        # print(f'{self.nick} is online!')
        print(f"{self.display_name} is online!")
        # Also post a message in chat upon connection
        for channel in self.channels:
            # await self.get_channel(channel).send(f"{self.display_name} is online!")
            pass

    # async def event(self, name: str = "imdad"):
        # return super().event(name)

    # add this and other event handlers to a cog:
    async def event_message(self, message):
        # Messages with echo set to True are messages sent by the bot...
        # For now we just want to ignore them...
        if message.echo:
            return


        # Print the contents of our message to console...
        # Also may be useful to append to a log file
        #####if message.echo:
        #print(message.content)

        # Since we have commands and are overriding the default `event_message`
        # We must let the bot know we want to handle and invoke our commands...
        await self.handle_commands(message)


class StrCommands(commands.Cog):
    '''Cog class for string commands.
    Run prepare_bot() to add this cog to a bot.'''
    def __init__(self, bot: commands.Bot) -> None:
        self.bot = bot
        # super().__init__()
        # pass

    @commands.command(name="testmsg")
    async def command_testmsg(self, ctx: commands.Context):
        msg = ctx.message.content
        au = ctx.author
        # print(au._fetch_channel().user())
        # await ctx.send(str(len(au.user().fetch_followers()) )) # fetch_following())
        # myuserobj = au.user()
        # mychatterobj = ctx.get_user(au.name)
        # print(mychatterobj)
        # print(chatter.Chatter.)

        # print(User("https://twitch.tv/"+str(mychatterobj.channel), {}))

        # print(myuserobj)
        
        # print(chatter.User.fetch_followers(()))
        # print(chatter.User.fetch_followers(au.user()))
        # await ctx.send(str(au.user()))
        # print(au.id, au.mention, au.name, au.display_name, au.color)
        # print(ctx.command.  parse_args(ctx, None, parsed={}))
        # await ctx.send("")
        #fetch_followers())
        # print(isinstance(msg, str))
        #await ctx.send(str(ctx.author.color))#{ctx.message.content}))
        # msg = "!testmsg arg1 arg2 arg3"
        # print(msg)))
        # print(msg.lstrip(r"^.*\s"), msg.removeprefix(r"!.*\s"))
        #print(ctx.message.raw_data)
        await ctx.send("I'm awake!")
        return
    
    @commands.command(name="uwu")
    async def command_uwu(self, ctx: commands.Context):
        # msg = ctx.message.content.lstrip(f"{BOT_PREFIX}{uwu.__name__}")
        msg = str(ctx.message.content).partition(' ')[2]
        # print(msg)
        await ctx.send(string_commands.uwu(msg))
        # await ctx.send(uwu(msg))
        # return uwu(query)

    @commands.command(name="derp", ) # aliases=("testmsg",))
    async def command_derp(self, ctx: commands.Context):
        # msg = ctx.message.content
        msg = str(ctx.message.content).partition(' ')[2]
        await ctx.send(string_commands.derp(msg))

    @commands.command(name="i'm", aliases=("im", "i am"))
    async def imdad(self, ctx: commands.Context):
        msg = str(ctx.message.content).partition(' ')[2]
        await ctx.send(string_commands.imdad(msg))

        

    #@commands.command()
    #async def hello(self, ctx: commands.Context):
        # Here we have a command hello, we can invoke our command with our prefix and command name
        # e.g ?hello
        # We can also give our commands aliases (different names) to invoke with.

        # Send a hello back!
        # Sending a reply back to the channel is easy... Below is an example.
        #await ctx.send(f'Hello, {ctx.author.display_name}!')
    

class TriggersCog(commands.Cog):
    def __init__(self, bot: commands.Bot) -> None:
        # super().__init__()
        self.bot = bot

    # async def event_message(selft msg)




    ###############async def add_command(self, command=commands.Command(name, func)):

    ###############add_command(self, command=commands.Command(name='!pleasework', func=print("did this work?")))
    #Bot.add_command(self, command)


def prepare_bot(bot: commands.Bot, cogs: tuple[commands.Cog]):
    '''Prepare a bot object with cogs, etc.'''
    for cog in cogs:
        bot.add_cog(cog)





mybot = BaseBot()

# print(bot.commands)




prepare_bot(bot=mybot, cogs=(StrCommands(mybot),))
mybot.run()
# bot.run() is blocking and will stop execution of any below code here until stopped or closed.

'''
@bot.event
async def event_ready():
    'Called once when the bot goes online.'
    print(f"{os.environ['BOT_NICK']} is online!")
    ws = bot._ws  # this is only needed to send messages within event_ready
    await ws.send_privmsg(os.environ['CHANNEL'], f"/me is online!")

@bot.event
async def event_message(ctx):
    'Runs every time a message is sent in chat.'

    # make sure the bot ignores itself and the streamer:
    if ctx.author.name.lower() == os.environ['BOT_NICK'].lower():
        return

 

    
    await bot.handle_commands(ctx)


    if 'hello' in ctx.content.lower():
        await ctx.channel.send(f"Hi, @{ctx.author.name}!")


@bot.command(name='test')
async def test(ctx):
    await ctx.send('/me is online!')

@bot.command(name='randword')
async def rand_word(ctx):
    msg = eng.rand_word()
    await ctx.send(msg)

@bot.command(name='randdef')
async def rand_def(ctx):
    msg = eng.rand_def()
    await ctx.send(msg)

@bot.command(name='define')
async def define(ctx):
    query = str(ctx.content).replace('!define','')
    # offer_choice = f"[num_matches] definitions found for '[word]'. Please choose a definition (1-[num_matches] / ALL):\n> " 
    msg = eng.define(query)
    if eng.needs_input:
        await ctx.send(eng.offer_choice)
        # choice =  await ctx.next_input or something()

    # print(str(ctx.content).replace('!define',''))
    await ctx.send(msg)

korok_list = []

@bot.command(name='klist')
async def klist(ctx):
    global korok_list 
    def get_missing(my_list):
        if korok_list == []:
            msg = "No Koroks reported missing."
        else: return f"Missing Koroks: {', '.join(my_list)}"
    #query = str(ctx.content).replace(',','').replace('!klist','').split(' ').remove('')
    query = [word.replace(',','') for word in str(ctx.content).split() if word != '!klist']
    if len(query) > 0:
        if query[0] == 'remove':
            korok_list.remove(query[1])
            msg = f"Removed 1 Korok. {get_missing(korok_list)}"
        elif query[0] == 'clear':
            korok_list.clear()
            msg = "Korok list cleared :D"
        elif len(query) >= 1:
            korok_list.extend(query)
            msg = get_missing(korok_list)
    else: msg = get_missing(korok_list)
    #msg = query

    await ctx.send(msg)


if __name__ == "__main__":
  bot.run()

'''